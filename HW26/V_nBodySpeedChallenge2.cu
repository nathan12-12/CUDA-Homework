// Name: Nathan S // nvcc -O3 --use_fast_math -maxrregcount=64 V_nBodySpeedChallenge2.cu -o temp2 -lglut -lm -lGLU -lGL
#include <GL/glut.h> 
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#define UNROLL64 _Pragma("unroll 64")
constexpr int BLOCK_SIZE = 256;constexpr float PI = 3.14159265359f;constexpr int DRAW_RATE = 10;constexpr float G = 10.0f;constexpr float H = 10.0f;constexpr float LJP = 2.0; constexpr float LJQ = 4.0;constexpr float RUN_TIME = 1.0;int N, DrawFlag;float3 *P, *V, *F;float *M; float3 *PGPU, *VGPU, *FGPU;float *MGPU;float GlobeRadius, Diameter, Radius;float Damp;dim3 BlockSize;dim3 GridSize;void cudaErrorCheck(const char *, int);void keyPressed(unsigned char, int, int);long elaspedTime(struct timeval, struct timeval);void drawPicture();void timer();void setup();__global__ void getForces(float3 *, float3 *, float *, float, float, int);__global__ void moveBodies(float3 *, float3 *, float3 *, float *, float, float, float, int);void nBody();int main(int, char**);void cudaErrorCheck(const char *file, int line){cudaError_t  error;error = cudaGetLastError();if(error != cudaSuccess){printf("\n CUDA ERROR: message = %s, File = %s, Line = %d\n", cudaGetErrorString(error), file, line-1);exit(0);}}void keyPressed(unsigned char key, int x, int y){if(key == 's'){printf("\n The simulation is running.\n");timer();}if(key == 'q'){exit(0);}}long elaspedTime(struct timeval start, struct timeval end){long startTime = start.tv_sec * 1000000 + start.tv_usec;long endTime = end.tv_sec * 1000000 + end.tv_usec;return endTime - startTime;}void drawPicture(){int i;glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);cudaMemcpyAsync(P, PGPU, N*sizeof(float3), cudaMemcpyDeviceToHost);cudaErrorCheck(__FILE__, __LINE__);glColor3d(1.0,1.0,0.5);for(i=0; i<N; i++){glPushMatrix();glTranslatef(P[i].x, P[i].y, P[i].z);glutSolidSphere(Radius,20,20);glPopMatrix();}glutSwapBuffers();}void timer(){timeval start, end;long computeTime;drawPicture();gettimeofday(&start, NULL);nBody();cudaDeviceSynchronize();cudaErrorCheck(__FILE__, __LINE__);gettimeofday(&end, NULL);drawPicture();computeTime = elaspedTime(start, end);printf("\n The compute time was %ld microseconds.\n\n", computeTime);printf(" The compute time was %f seconds.\n\n", float(computeTime)/1000000.0f);}constexpr float computeDiameter(float H, float G, float LJP, float LJQ){const float invExp = 0.5f;const float ratio = 1.0f;return 1.0f;}void setup(){float randomAngle1, randomAngle2, randomRadius;float d, dx, dy, dz;int test;	BlockSize.x = BLOCK_SIZE;BlockSize.y = 1;BlockSize.z = 1;GridSize.x = (N - 1)/BlockSize.x + 1;GridSize.y = 1;GridSize.z = 1;Damp = 0.5;	M = (float*)malloc(N*sizeof(float));cudaMallocHost(&P, N * sizeof(float3));V = (float3*)malloc(N*sizeof(float3));F = (float3*)malloc(N*sizeof(float3));	cudaMalloc(&MGPU,N*sizeof(float));cudaErrorCheck(__FILE__, __LINE__);cudaMalloc(&PGPU,N*sizeof(float3));cudaErrorCheck(__FILE__, __LINE__);cudaMalloc(&VGPU,N*sizeof(float3));cudaErrorCheck(__FILE__, __LINE__);cudaMalloc(&FGPU,N*sizeof(float3));cudaErrorCheck(__FILE__, __LINE__);Diameter = 1.0f;Radius = Diameter * 0.5f;constexpr float DiameterSquared = 1.0f;constexpr float invRANDMAX = 1.0f / (float)RAND_MAX;constexpr float inv_packing_ratio = 1.47058823529f;constexpr float sphere_volume_constant = 0.238732414638f;constexpr float twoPi = 6.28318530718;constexpr float fourOverThree = 1.33333333333f;float totalVolume = float(N)*0.5235987755982988;totalVolume *= inv_packing_ratio;float totalRadius = cbrtf(sphere_volume_constant * totalVolume);GlobeRadius = 2.0*totalRadius;UNROLL64 for(int i = 0; i < N; i++){test = 0;while(test == 0){randomAngle1 = ((float)rand() * invRANDMAX) * twoPi;randomAngle2 = ((float)rand() * invRANDMAX) * PI;randomRadius = ((float)rand() * invRANDMAX) * GlobeRadius;P[i].x = randomRadius*cos(randomAngle1)*sin(randomAngle2);P[i].y = randomRadius*sin(randomAngle1)*sin(randomAngle2);P[i].z = randomRadius*cos(randomAngle2);test = 1;for(int j = 0; j < i; j++){dx = P[i].x-P[j].x;dy = P[i].y-P[j].y;dz = P[i].z-P[j].z;d = dx*dx + dy*dy + dz*dz;if(d < DiameterSquared){test = 0;break;}}}V[i].x = 0.0;V[i].y = 0.0;V[i].z = 0.0;F[i].x = 0.0;F[i].y = 0.0;F[i].z = 0.0;M[i] = 1.0;}cudaMemcpy(PGPU, P, N*sizeof(float3), cudaMemcpyHostToDevice);cudaErrorCheck(__FILE__, __LINE__);cudaMemcpy(VGPU, V, N*sizeof(float3), cudaMemcpyHostToDevice);cudaErrorCheck(__FILE__, __LINE__);cudaMemcpy(FGPU, F, N*sizeof(float3), cudaMemcpyHostToDevice);cudaErrorCheck(__FILE__, __LINE__);cudaMemcpy(MGPU, M, N*sizeof(float), cudaMemcpyHostToDevice);cudaErrorCheck(__FILE__, __LINE__);printf("\n To start timing go to the nBody window and type s.\n");printf("\n To quit type q in the nBody window.\n");}__global__ void getForces(float3 *p, float3 *f, float *m, float g, float h, int n){__shared__ float3 sharedPosition[BLOCK_SIZE];__shared__ float sharedMass[BLOCK_SIZE];int i = threadIdx.x + blockDim.x * blockIdx.x;float3 myPosition, myForce = {0.0f, 0.0f, 0.0f};float myMass;if (i < n) {myPosition.x = __ldg(&p[i].x);myPosition.y = __ldg(&p[i].y);myPosition.z = __ldg(&p[i].z);myMass = __ldg(&m[i]);}float g_mass = g * myMass;float h_mass = h * myMass;UNROLL64 for (int tile = 0; tile < gridDim.x; tile++) {int idx = tile * blockDim.x + threadIdx.x;sharedPosition[threadIdx.x] = (idx < n) ? p[idx] : make_float3(0.0f, 0.0f, 0.0f);sharedMass[threadIdx.x] = (idx < n) ? m[idx] : 0.0f;__syncthreads();if (i < n) {UNROLL64 for (int j = 0; j < blockDim.x; j++) {int globalJ = tile * blockDim.x + j;if (globalJ < n && i != globalJ) {float dx = sharedPosition[j].x - myPosition.x;float dy = sharedPosition[j].y - myPosition.y;float dz = sharedPosition[j].z - myPosition.z;float d2 = dx*dx + dy*dy + dz*dz;float invd = rsqrtf(d2);float invd2 = invd * invd;float invd4 = invd2 * invd2;float massTerm = sharedMass[j] * (g_mass*invd2 - h_mass*invd4);myForce.x = fmaf(massTerm * dx, invd, myForce.x);myForce.y = fmaf(massTerm * dy, invd, myForce.y);myForce.z = fmaf(massTerm * dz, invd, myForce.z);}}}__syncthreads();}if (i < n) {f[i] = myForce;}}__global__ void moveBodies(float3 *p, float3 *v, float3 *f, float *m, float damp, float dt, float t, int n){int i = threadIdx.x + blockDim.x*blockIdx.x;float halfDt = dt * 0.5f;if(i < n){if(t == 0.0f){v[i].x += ((f[i].x-damp*v[i].x)/m[i])*halfDt;v[i].y += ((f[i].y-damp*v[i].y)/m[i])*halfDt;v[i].z += ((f[i].z-damp*v[i].z)/m[i])*halfDt;}else{v[i].x += ((f[i].x-damp*v[i].x)/m[i])*dt;v[i].y += ((f[i].y-damp*v[i].y)/m[i])*dt;v[i].z += ((f[i].z-damp*v[i].z)/m[i])*dt;}p[i].x += v[i].x*dt;p[i].y += v[i].y*dt;p[i].z += v[i].z*dt;}}__global__ void combined(float3 *p, float3 *v, float3 *f, float *m, float damp, float dt, float t, float g, float h, int n){__shared__ float3 sharedPos[BLOCK_SIZE];__shared__ float sharedMass[BLOCK_SIZE];int i = threadIdx.x + blockDim.x * blockIdx.x;float3 myPosition, myForce = {0.0f, 0.0f, 0.0f};float myMass;if (i < n) {myPosition.x = __ldg(&p[i].x);myPosition.y = __ldg(&p[i].y);myPosition.z = __ldg(&p[i].z);myMass = __ldg(&m[i]);}float g_mass = g * myMass;float h_mass = h * myMass;for (int tile = 0; tile < gridDim.x; tile++) {int idx = tile * blockDim.x + threadIdx.x;sharedPos[threadIdx.x] = (idx < n) ? p[idx] : make_float3(0.0f, 0.0f, 0.0f);sharedMass[threadIdx.x] = (idx < n) ? m[idx] : 0.0f;__syncthreads();if (i < n) {UNROLL64 for (int j = 0; j < blockDim.x; j++) {int globalJ = tile * blockDim.x + j;if (globalJ < n && i != globalJ) {float dx = sharedPos[j].x - myPosition.x;float dy = sharedPos[j].y - myPosition.y;float dz = sharedPos[j].z - myPosition.z;float d2 = dx*dx + dy*dy + dz*dz;float invd = rsqrtf(d2);float invd2 = invd * invd;float invd4 = invd2 * invd2;float massTerm = sharedMass[j] * (g_mass*invd2 - h_mass*invd4);myForce.x = fmaf(massTerm * dx, invd, myForce.x);myForce.y = fmaf(massTerm * dy, invd, myForce.y);myForce.z = fmaf(massTerm * dz, invd, myForce.z);}}}__syncthreads();}if (i < n) {float halfDt = dt * 0.5f;float invMass = 1.0f / myMass;f[i] = myForce;if(t == 0.0f) {v[i].x += ((myForce.x - damp*v[i].x)*invMass)*halfDt;v[i].y += ((myForce.y - damp*v[i].y)*invMass)*halfDt;v[i].z += ((myForce.z - damp*v[i].z)*invMass)*halfDt;}else{v[i].x += ((myForce.x - damp*v[i].x)*invMass)*dt;v[i].y += ((myForce.y - damp*v[i].y)*invMass)*dt;v[i].z += ((myForce.z - damp*v[i].z)*invMass)*dt;}p[i].x += v[i].x*dt;p[i].y += v[i].y*dt;p[i].z += v[i].z*dt;}}void nBody() {cudaStream_t computeStream, transferStream;cudaStreamCreate(&computeStream);cudaStreamCreate(&transferStream);int drawCount = 0;float t = 0.0f;float dt = 0.0001f;while (t < RUN_TIME) {getForces<<<GridSize, BlockSize, 0, computeStream>>>(PGPU, FGPU, MGPU, G, H, N);cudaErrorCheck(__FILE__, __LINE__);moveBodies<<<GridSize, BlockSize, 0, computeStream>>>(PGPU, VGPU, FGPU, MGPU, Damp, dt, t, N);cudaErrorCheck(__FILE__, __LINE__);if (drawCount == DRAW_RATE && DrawFlag) {cudaMemcpyAsync(P, PGPU, N * sizeof(float3), cudaMemcpyDeviceToHost, transferStream);cudaStreamSynchronize(transferStream);drawPicture();drawCount = 0;}t += dt;drawCount++;}cudaStreamDestroy(computeStream);cudaStreamDestroy(transferStream);}int main(int argc, char** argv){if( argc < 3){printf("\n You need to enter the number of bodies (an int)"); printf("\n and if you want to draw the bodies as they move (1 draw, 0 don't draw),");printf("\n on the comand line.\n"); exit(0);}N = atoi(argv[1]);DrawFlag = atoi(argv[2]);if (N <= 256){printf("\nError: Number of bodies (%d) must be greater than 256.\n", N);exit(1);}if (N >= 262144){printf("\nError: Number of bodies (%d) must be less than 262144.\n", N);exit(1);}if ((N & (N - 1)) != 0){printf("\nError: Number of bodies (%d) must be a power of 2 (e.g., 512, 1024, 2048, ..., 131072).\n", N);exit(1);}setup();constexpr int XWindowSize = 1000;constexpr int YWindowSize = 1000;glutInit(&argc,argv);glutInitDisplayMode(GLUT_DOUBLE | GLUT_DEPTH | GLUT_RGB);glutInitWindowSize(XWindowSize,YWindowSize);glutInitWindowPosition(0,0);glutCreateWindow("Modified nBody Challenge");GLfloat light_position[] = {1.0, 1.0, 1.0, 0.0};GLfloat light_ambient[]  = {0.0, 0.0, 0.0, 1.0};GLfloat light_diffuse[]  = {1.0, 1.0, 1.0, 1.0};GLfloat light_specular[] = {1.0, 1.0, 1.0, 1.0};GLfloat lmodel_ambient[] = {0.2, 0.2, 0.2, 1.0};GLfloat mat_specular[]={1.0, 1.0, 1.0, 1.0};GLfloat mat_shininess[]  = {10.0};glClearColor(0.0, 0.0, 0.0, 0.0);glShadeModel(GL_SMOOTH);glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);glLightfv(GL_LIGHT0, GL_POSITION, light_position);glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);glEnable(GL_LIGHTING);glEnable(GL_LIGHT0);glEnable(GL_COLOR_MATERIAL);glEnable(GL_DEPTH_TEST);glutKeyboardFunc(keyPressed);glutDisplayFunc(drawPicture);float3 eye = {0.0f, 0.0f, 2.0f*GlobeRadius};float near = 0.2;float far = 5.0*GlobeRadius;glMatrixMode(GL_PROJECTION);glLoadIdentity();glFrustum(-0.2, 0.2, -0.2, 0.2, near, far);glMatrixMode(GL_MODELVIEW);glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);gluLookAt(eye.x, eye.y, eye.z, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);glutMainLoop();cudaFreeHost(P);free(V);free(F);free(M);cudaFree(MGPU);cudaFree(PGPU);cudaFree(VGPU);cudaFree(FGPU);return 0;}